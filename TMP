module Tfr_chk_spec:tParam = struct

type ref = {
	spec : specification ;
	proc_cur : process list;
	proc_ref : process;
}

	module CsParam : tRef with type r = ref = struct
		type r = ref
		type p = unit

		let creerRef s = {
			spec = s ;
			proc_cur = [];
			proc_ref = {
				header = {
					process_name = "";
					signal_declarations = {
						input_signal_list = [];
						output_signal_list = [] ;
						local_signal_list = [] ;
					};
					local_process_list = [];
				};
				body = {
					assignment_list = [];
					constraint_list = [];
					instantiation_list = [];
				};
			};
		}
		let getRef _ = {
			spec = { 
				process_list = [] ;
				type_declaration_list = [] ;
				procedure_declaration_list = [] ;
			};
			proc_cur = [];
			proc_ref = {
				header = {
					process_name = "";
					signal_declarations = {
						input_signal_list = [];
						output_signal_list = [] ;
						local_signal_list = [] ;
					};
					local_process_list = [];
				};
				body = {
					assignment_list = [];
					constraint_list = [];
					instantiation_list = [];
				};
			};
		}
		let setRef _ _ = {
			spec = { 
				process_list = [] ;
				type_declaration_list = [] ;
				procedure_declaration_list = [] ;
			};
			proc_cur = [];
			proc_ref = {
				header = {
					process_name = "";
					signal_declarations = {
						input_signal_list = [];
						output_signal_list = [] ;
						local_signal_list = [] ;
					};
					local_process_list = [];
				};
				body = {
					assignment_list = [];
					constraint_list = [];
					instantiation_list = [];
				};
			};
		}
		let tstRef _ _= true
		let verifRef _ _ =  {
			spec = { 
				process_list = [] ;
				type_declaration_list = [] ;
				procedure_declaration_list = [] ;
			};
			proc_cur = [];
			proc_ref = {
				header = {
					process_name = "";
					signal_declarations = {
						input_signal_list = [];
						output_signal_list = [] ;
						local_signal_list = [] ;
					};
					local_process_list = [];
				};
				body = {
					assignment_list = [];
					constraint_list = [];
					instantiation_list = [];
				};
			};
		}
		let getPart _ = ()
	end

	include Identite(CsParam)
	let gR = CsParam.getRef
	let sR = CsParam.setRef
	let tR = CsParam.tstRef
	let vR = CsParam.verifRef
	
	(*let tfr_proced_decla param name inp outp =
	    let list_nom = List.find (fun e -> e.procedure_name = nom) param.spec.procedure_declaration_list
	    let testUnique = if *)

	let tfr_typed_var_set t type_name v =
	if(List.length (List.filter (fun x -> x.tv_type_name = type_name) t.spec.type_declaration_list) > 1)
	then raise (Multiple_definition(" of type "^type_name^"\n"))
	else	({
				tv_type_name = type_name;
				variant_set = v;
			}, t)

	let tfr_sig_decla t sName sType sDir =
		let p = List.hd t.proc_cur in
		if(List.exists (fun x -> x.tv_type_name = sType) t.spec.type_declaration_list)
		then
			if(List.length (List.filter
								(fun x -> x.signal_name = sName)
								( (p.header.signal_declarations.input_signal_list
								@ p.header.signal_declarations.output_signal_list)
								@ p.header.signal_declarations.local_signal_list )
							) > 1)
			then raise (Multiple_definition(" of signal "^sName^" in process "^p.header.process_name^"\n"))
			else ({
					signal_name = sName;
					signal_type = sType;
					signal_direction = sDir;
				}, t)
		else raise (Not_define(" type "^sType^"at the declaration of"^sName^" in process "^p.header.process_name^"\n"))

	let tfr_sig_declas t inL outL localL =
	if(	   (List.for_all (fun x -> x.signal_direction = Input) inL)
		&& (List.for_all (fun x -> x.signal_direction = Output) outL)
		&& (List.for_all (fun x -> x.signal_direction = Local) localL))
	then 	({
				input_signal_list = inL;
				output_signal_list = outL;
				local_signal_list = localL;
			}, t)
	else raise (Incompatible_definitions(" in process "^((List.hd t.proc_cur).header.process_name)^", some signals are record in a list that mismatch with the direction\n"))
	
